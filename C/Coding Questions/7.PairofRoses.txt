Problem Name: Pair of Roses
Problem Difficulty: None
Problem Constraints: 1≤ T ≤100<br>
2 ≤ N ≤ 10000<br>
Price[i]<1000001
Problem Description:
Deepak has a limited amount of money that he can spend on his girlfriend. So he decides to buy two roses
for her. Since roses are of varying sizes, their prices are different. Deepak wishes to completely spend that fixed amount of money on buying roses for her.<br>
As he wishes to spend all the money, he should choose a pair of roses whose prices when summed up are equal to the money that he has.<br>
Help Deepak choose such a pair of roses for his girlfriend.<br /><br>
NOTE:</b> If there are multiple solutions print the solution that minimizes the difference between the prices i and j. After each test case, you must print a blank line.
Input Format: The first line indicates the number of test cases T.<br>
Then, in the next line, the number of available roses, N is given.<br>
The next line will have N integers, representing the price of each rose, a rose that costs less than 1000001.<br>
Then there is another line with an integer M, representing how much money Deepak has.<br>
There is a blank line after each test case.
Sample Input: 2
2
40 40
80

5
10 2 6 8 4
10

Output Format: For each test case, you must print the message: ‘Deepak should buy roses whose prices are i and
j.’, where i and j are the prices of the roses whose sum is equal do M and i ≤ j. You can consider that it
is always possible to find a solution. If there are multiple solutions print the solution that minimizes
the difference between the prices i and j.

Sample Output: Deepak should buy roses whose prices are 40 and 40.
Deepak should buy roses whose prices are 4 and 6.



=====Solution=====

#include<bits/stdc++.h>
// #include<unordered_set>
using namespace std;
 #define fio ios_base::sync_with_stdio(false)
 
#define ll long long int

#define s(x) scanf("%lld",&x)
#define s2(x,y) s(x)+s(y)
#define s3(x,y,z) s(x)+s(y)+s(z)
 
#define p(x) printf("%lld\n",x)
#define p2(x,y) p(x)+p(y)
#define p3(x,y,z) p(x)+p(y)+p(z)
#define F(i,a,b) for(ll i = (ll)(a); i <= (ll)(b); i++)
#define RF(i,a,b) for(ll i = (ll)(a); i >= (ll)(b); i--)
 
#define ff first
#define ss second
#define mp(x,y) make_pair(x,y)
#define pll pair<ll,ll>
#define pb push_back

ll inf = 1e18;
ll mod = 1e9 + 7 ;
ll gcd(ll a , ll b){return b==0?a:gcd(b,a%b);}

int main()
{
  // freopen("input.txt","r",stdin);
    // freopen("output.txt","w",stdout);
  ll n;
  ll ct=0;
  ll t;
  s(t);
  while(t--){
    cin>>n;
    ct++;
    // Accept the input in a vector 
    vector<ll>ar(n);
    for(ll i=0;i<n;i++)cin>>ar[i];

    // Sort the vector in ascending order
    sort(ar.begin(), ar.end());

    // Accept the money Deepak has
    ll tar;
    s(tar);

    // Since in cases of multiple solutions, we have to output that one which
    // has the minimum difference betweeen the two prices of the roses, so we
    // are maintaining the difference for every solution and will output the one
    // with minimum difference. Initially, the minimum difference is assumed to be 
    // infinity.

    ll curDif=INT_MAX;
    ll p1,p2;

    for(ll i=0;i<n-1;i++){
      if(ar[i]>tar)break;
      
      // toFind is the value of the price of the second rose in the pair
      ll tofind=tar-ar[i];

      // ind is the index of the toFind variable in the sorted array if it exists
      ll ind = lower_bound(ar.begin()+i+1,ar.end(),tofind)-ar.begin();

      // if ind is greater than n, it indicates that the second rose of the pair 
      // does not exists, so continue finding another pair.
      if(ind>=n)continue;

      // if we have found the second rose of the pair, we will check for the minimum difference condition
      // and then assign the value of the two prices in p1 and p2.
      if(ar[ind]==tofind){
        if(ar[ind]-ar[i]<curDif){
          curDif=ar[ind]-ar[i];
          p1=ar[i];
          p2=ar[ind];
        }
      }
    }
    cout<<"Deepak should buy roses whose prices are "<<p1<<" and "<<p2<<"."<<endl;
  }
}

